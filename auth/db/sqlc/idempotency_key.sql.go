// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: idempotency_key.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const deleteIdempotencyKeyByID = `-- name: DeleteIdempotencyKeyByID :exec
DELETE FROM idempotency_keys
WHERE key_id = $1
`

func (q *Queries) DeleteIdempotencyKeyByID(ctx context.Context, keyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteIdempotencyKeyByID, keyID)
	return err
}

const deleteIdempotencyKeysByExpiredAt = `-- name: DeleteIdempotencyKeysByExpiredAt :exec
DELETE FROM idempotency_keys
WHERE expired_at < NOW()
`

func (q *Queries) DeleteIdempotencyKeysByExpiredAt(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteIdempotencyKeysByExpiredAt)
	return err
}

const getIdempotencyKeyByID = `-- name: GetIdempotencyKeyByID :one
SELECT key_id, status, response_message, created_at, updated_at, expired_at FROM idempotency_keys WHERE key_id = $1
`

func (q *Queries) GetIdempotencyKeyByID(ctx context.Context, keyID uuid.UUID) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, getIdempotencyKeyByID, keyID)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.Status,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getOrClaimIdempotencyKey = `-- name: GetOrClaimIdempotencyKey :one
INSERT INTO idempotency_keys (
     -- Insert a new idempotency key. If concurrenct transactions already created the key, its status should be "COMPLETED" or "FAILED". 
     -- Else, we're the first to create it, and we set it to "PENDING".
     -- This statement will blockResponseMessage if there are concurrent transactions inserting the same row, even if they haven't been committed/rollbacked.
    key_id,
    status,            
    response_message,     
    created_at,
    updated_at,
    expired_at
)
VALUES (
    $1,  
    'PENDING',
    'placeholder', 
    NOW(),
    NOW(),
    NOW() + interval '24 hours'
)
ON CONFLICT (key_id, user_id)
DO UPDATE SET
    -- Only touch 'updated_at' if the existing status is 'PENDING', to signify this transaction is actively looking at it.
    -- If it's already 'COMPLETED' or 'FAILED', we don't want to modify it here; RETURNING * will give us its state.
    -- The 'status' is NOT changed here by the DO UPDATE clause if it was already terminal.
    -- If it was PENDING, it remains PENDING. If it was a new insert, it gets the $3 status.
    updated_at = CASE
                    WHEN idempotency_keys.status = 'PENDING' -- $3 is 'PENDING'
                        THEN NOW()
                    ELSE idempotency_keys.updated_at -- Keep existing updated_at if it was COMPLETED/FAILED or different pending
                 END
RETURNING key_id, status, response_message, created_at, updated_at, expired_at
`

func (q *Queries) GetOrClaimIdempotencyKey(ctx context.Context, keyID uuid.UUID) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, getOrClaimIdempotencyKey, keyID)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.Status,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateIdempotencyKey = `-- name: UpdateIdempotencyKey :one
UPDATE idempotency_keys
SET status = $1, response_message = $2, updated_at = NOW(), expired_at = NOW() + interval '24 hours'
WHERE key_id = $3
RETURNING key_id, status, response_message, created_at, updated_at, expired_at
`

type UpdateIdempotencyKeyParams struct {
	Status          string    `json:"status"`
	ResponseMessage string    `json:"response_message"`
	KeyID           uuid.UUID `json:"key_id"`
}

func (q *Queries) UpdateIdempotencyKey(ctx context.Context, arg UpdateIdempotencyKeyParams) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, updateIdempotencyKey, arg.Status, arg.ResponseMessage, arg.KeyID)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.Status,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateIdempotencyKeyByID = `-- name: UpdateIdempotencyKeyByID :exec
UPDATE idempotency_keys
SET status = $1, response_message = $2, updated_at = NOW()
WHERE key_id = $3
`

type UpdateIdempotencyKeyByIDParams struct {
	Status          string    `json:"status"`
	ResponseMessage string    `json:"response_message"`
	KeyID           uuid.UUID `json:"key_id"`
}

func (q *Queries) UpdateIdempotencyKeyByID(ctx context.Context, arg UpdateIdempotencyKeyByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateIdempotencyKeyByID, arg.Status, arg.ResponseMessage, arg.KeyID)
	return err
}
