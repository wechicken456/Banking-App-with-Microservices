// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: idempotency_key.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createIdempotencyKey = `-- name: CreateIdempotencyKey :one
INSERT INTO idempotency_keys (key_id, user_id, status, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING key_id, user_id, status, response_code, response_message, created_at, updated_at, expired_at
`

type CreateIdempotencyKeyParams struct {
	KeyID  uuid.UUID `json:"key_id"`
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
}

func (q *Queries) CreateIdempotencyKey(ctx context.Context, arg CreateIdempotencyKeyParams) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, createIdempotencyKey, arg.KeyID, arg.UserID, arg.Status)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.UserID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const deleteIdempotencyKeyByID = `-- name: DeleteIdempotencyKeyByID :exec
DELETE FROM idempotency_keys
WHERE key_id = $1
`

func (q *Queries) DeleteIdempotencyKeyByID(ctx context.Context, keyID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteIdempotencyKeyByID, keyID)
	return err
}

const deleteIdempotencyKeysByExpiredAt = `-- name: DeleteIdempotencyKeysByExpiredAt :exec
DELETE FROM idempotency_keys
WHERE expired_at < NOW()
`

func (q *Queries) DeleteIdempotencyKeysByExpiredAt(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteIdempotencyKeysByExpiredAt)
	return err
}

const deleteIdempotencyKeysByUserID = `-- name: DeleteIdempotencyKeysByUserID :exec
DELETE FROM idempotency_keys
WHERE user_id = $1
`

func (q *Queries) DeleteIdempotencyKeysByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteIdempotencyKeysByUserID, userID)
	return err
}

const getIdempotencyKeyByID = `-- name: GetIdempotencyKeyByID :one
SELECT key_id, user_id, status, response_code, response_message, created_at, updated_at, expired_at FROM idempotency_keys WHERE key_id = $1
`

func (q *Queries) GetIdempotencyKeyByID(ctx context.Context, keyID uuid.UUID) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, getIdempotencyKeyByID, keyID)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.UserID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getOrClaimIdempotencyKey = `-- name: GetOrClaimIdempotencyKey :one
INSERT INTO idempotency_keys (
     -- Insert a new idempotency key. If concurrenct transactions already created the key, its status should be "COMPLETED" or "FAILED". 
     -- Else, we're the first to create it, and we set it to "PENDING".
     -- This statement will blockResponseMessage if there are concurrent transactions inserting the same row, even if they haven't been committed/rollbacked.
    key_id,
    user_id,
    status,            
    response_code,      
    response_message,     
    created_at,
    updated_at,
    expired_at
)
VALUES (
    $1,  
    $2,  -
    'PENDING',
    0, 
    "placeholder", 
    NOW(),
    NOW(),
    $3   -- expired_at (e.g., NOW() + interval '24 hours')
)
ON CONFLICT (idempotency_key_id, user_id)
DO UPDATE SET
    -- Only touch 'updated_at' if the existing status is 'PENDING', to signify this transaction is actively looking at it.
    -- If it's already 'COMPLETED' or 'FAILED', we don't want to modify it here; RETURNING * will give us its state.
    -- The 'status' is NOT changed here by the DO UPDATE clause if it was already terminal.
    -- If it was PENDING, it remains PENDING. If it was a new insert, it gets the $3 status.
    updated_at = CASE
                    WHEN idempotency_keys.status = 'PENDING' -- $3 is 'PENDING'
                        THEN NOW()
                    ELSE idempotency_keys.updated_at -- Keep existing updated_at if it was COMPLETED/FAILED or different pending
                 END
RETURNING key_id, user_id, status, response_code, response_message, created_at, updated_at, expired_at
`

type GetOrClaimIdempotencyKeyParams struct {
	KeyID     uuid.UUID    `json:"key_id"`
	UserID    uuid.UUID    `json:"user_id"`
	ExpiredAt sql.NullTime `json:"expired_at"`
}

func (q *Queries) GetOrClaimIdempotencyKey(ctx context.Context, arg GetOrClaimIdempotencyKeyParams) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, getOrClaimIdempotencyKey, arg.KeyID, arg.UserID, arg.ExpiredAt)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.UserID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateIdempotencyKey = `-- name: UpdateIdempotencyKey :one
UPDATE idempotency_keys
SET status = $1, response_code = $2, response_message = $3, updated_at = NOW(), expired_at = NOW() + interval '24 hours'
WHERE key_id = $4
RETURNING key_id, user_id, status, response_code, response_message, created_at, updated_at, expired_at
`

type UpdateIdempotencyKeyParams struct {
	Status          string    `json:"status"`
	ResponseCode    int32     `json:"response_code"`
	ResponseMessage string    `json:"response_message"`
	KeyID           uuid.UUID `json:"key_id"`
}

func (q *Queries) UpdateIdempotencyKey(ctx context.Context, arg UpdateIdempotencyKeyParams) (IdempotencyKey, error) {
	row := q.db.QueryRowContext(ctx, updateIdempotencyKey,
		arg.Status,
		arg.ResponseCode,
		arg.ResponseMessage,
		arg.KeyID,
	)
	var i IdempotencyKey
	err := row.Scan(
		&i.KeyID,
		&i.UserID,
		&i.Status,
		&i.ResponseCode,
		&i.ResponseMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateIdempotencyKeyByID = `-- name: UpdateIdempotencyKeyByID :exec
UPDATE idempotency_keys
SET status = $1, response_code = $2, response_message = $3, updated_at = NOW()
WHERE key_id = $4
`

type UpdateIdempotencyKeyByIDParams struct {
	Status          string    `json:"status"`
	ResponseCode    int32     `json:"response_code"`
	ResponseMessage string    `json:"response_message"`
	KeyID           uuid.UUID `json:"key_id"`
}

func (q *Queries) UpdateIdempotencyKeyByID(ctx context.Context, arg UpdateIdempotencyKeyByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateIdempotencyKeyByID,
		arg.Status,
		arg.ResponseCode,
		arg.ResponseMessage,
		arg.KeyID,
	)
	return err
}
